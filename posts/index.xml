<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on t4ccer</title>
        <link>/posts/</link>
        <description>Recent content in Posts on t4ccer</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Tue, 12 May 2020 00:00:00 +0000</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Dister32 - Part 1</title>
            <link>/posts/dister32-part1/</link>
            <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/dister32-part1/</guid>
            <description>Introduction Dister32 is my own projects for easy managment of distributed computing on cheap but powerful microcontroller ESP32. ESP32 has built-in wifi module so communication between modules will be fairly simple.
ESP-32s module
The article will be split into 3 parts.
In the first part, I will describe how the cluster will work and implement the simplest features. The second part will be published when ordered PCBs will arrive at me.</description>
            <content type="html"><![CDATA[<h3 id="introduction">Introduction</h3>
<p>Dister32 is my own projects for easy managment of distributed computing on cheap but powerful microcontroller <a href="https://www.espressif.com/en/products/socs/esp32/overview">ESP32</a>. ESP32 has built-in wifi module so communication between modules will be fairly simple.</p>
<p><img src="/img/esp32.png" alt="ESP32">
ESP-32s module</p>
<p>The article will be split into 3 parts.<br>
In the first part, I will describe how the cluster will work and implement the simplest features. The second part will be published when ordered PCBs will arrive at me. And last, third part will describe finished project and then I will publish sourcecode for nodes, master, and dashboard. Also in the last part, I will provide all necessary instructions to create own ESP32 cluster.</p>
<p>At first, let me explain some concepts:</p>
<ul>
<li>Node - is an esp32 module connected to MQTT broker.</li>
<li>Master - is a server connected to MQTT broker that manages nodes and images.</li>
<li>Image - is a compiled, binary program for node.</li>
<li>Pool - is a group of nodes running the same image.</li>
</ul>
<p>Cluster will work using <a href="http://mqtt.org/">MQTT</a> protocole to communicate with master server, and json to serialize data.</p>
<h3 id="node">Node</h3>
<p>Node is ESP32 microcontroller that runs dister32-compatible image. Each node is connected to mqtt broker via WiFi. Name of node is its MAC address without colons. Each node is described by its name, IP address, status (<code>OK</code>/<code>Error</code>/<code>Uploading</code>) and current image. Also, each node is running <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/ota.html">OTA</a> mechanism, therefore, its possible to update its firmware wirelessly.</p>
<h3 id="master">Master</h3>
<p>Master server manages nodes and pools. Master also provides HTTP REST API so it&rsquo;s easy to create a web dashboard(I&rsquo;ll try to create it soon).</p>
<h3 id="pool">Pool</h3>
<p>Pool has assigned image, nodes and count of active nodes. Master is making that exactly <code>count of active nodes</code> nodes will run assigned image. The rest of nodes will be inactive and ready to work if any of running node disconnects.</p>
<h3 id="features">Features</h3>
<ul>
<li>
<p>Welcome messages. Node on boot sends its properties(name, image, etc) with topic <code>dister32/NODE_NAME/welcome</code>. The same message is sent when node receives message with topic <code>dister32/NODE_NAME/introduce</code>.</p>
</li>
<li>
<p>Heartbeat. Master every <code>delay</code> milliseconds  sends message with topic <code>dister32/master/heartbeat/request</code>. Each node has to respond with <code>dister32/NODE_NAME/heartbeat/response</code>. If doesn&rsquo;t after <code>2*delay</code> ms its status is changed to <code>Error</code>. If master receives response from node that is not registered in cluster, master sends <code>dister32/NODE_NAME/introduce</code> message to get info about this node.</p>
</li>
<li>
<p>LED control. ESP32 has built-in LED so let&rsquo;s use it. Node can be in one of 3 states(<code>On</code>/<code>Off</code>/<code>Blink</code>). When node receives message <code>dister32/NODE_NAME/led</code> with content corresponding  to LED mode, it changes its led to that mode.</p>
</li>
</ul>
<h3 id="pcb">PCB</h3>
<p>To easily stack multiple ESP32 nodes I designed simple PCB, with power connectors and female goldpins for esp module. I designed PCB using <a href="https://easyeda.com/">EasyEDA</a> software and ordered on <a href="https://jlcPCB.com/">JLCPCB</a>. PCB is 6x6cm with 3mm holes on each corner, with 5mm from edge to center of the hole.</p>
<p><img src="/img/pcb1.png" alt="PCB"></p>
<p>I will publish the next part when PCBs arrive at me(it can take a little, I live in Europe).</p>
<p>If you want, for any reason, create your own cluster, I will publish all gerber files, source code, schematics, and tutorials when I publish the last part.</p>
<p>Note: Project is made just for fun, do not use in any serious environment.</p>
]]></content>
        </item>
        
        <item>
            <title>SharpNEAT Tutorial</title>
            <link>/posts/sharpneat-tutorial/</link>
            <pubDate>Thu, 07 May 2020 11:39:44 +0200</pubDate>
            
            <guid>/posts/sharpneat-tutorial/</guid>
            <description>SharpNEAT is great library for developing NEAT networks, but unfortunatly is very poorly documented, so I created some boilerplate code to kickstart Your project.
// inputCount - Count of inout neurons // outputCount - Count of output neurons // specimenCount - Specimen count in each generation  var neatGenomeFactory = new NeatGenomeFactory(inputCount, outputCount); var genomeList = neatGenomeFactory.CreateGenomeList(specimenCount, 0); var neatParameters = new NeatEvolutionAlgorithmParameters { SpecieCount = specimenCount }; var distanceMetric = new ManhattanDistanceMetric(); var speciationStrategy = new ParallelKMeansClusteringStrategy&amp;lt;NeatGenome&amp;gt; (distanceMetric); var complexityRegulationStrategy = new NullComplexityRegulationStrategy(); var network = new NeatEvolutionAlgorithm&amp;lt;NeatGenome&amp;gt; (neatParameters, speciationStrategy, complexityRegulationStrategy); var activationScheme = NetworkActivationScheme .</description>
            <content type="html"><![CDATA[<p><a href="https://github.com/colgreen/sharpneat">SharpNEAT</a> is great library for developing <a href="https://en.wikipedia.org/wiki/Neuroevolution_of_augmenting_topologies">NEAT</a> networks, but unfortunatly is very poorly documented, so I created some boilerplate code to kickstart Your project.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#75715e">// inputCount - Count of inout neurons
</span><span style="color:#75715e">// outputCount - Count of output neurons
</span><span style="color:#75715e">// specimenCount - Specimen count in each generation
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">var</span> neatGenomeFactory = <span style="color:#66d9ef">new</span> NeatGenomeFactory(inputCount, outputCount);
<span style="color:#66d9ef">var</span> genomeList = neatGenomeFactory.CreateGenomeList(specimenCount, <span style="color:#ae81ff">0</span>);
<span style="color:#66d9ef">var</span> neatParameters = <span style="color:#66d9ef">new</span> NeatEvolutionAlgorithmParameters
{
    SpecieCount = specimenCount
};

<span style="color:#66d9ef">var</span> distanceMetric = <span style="color:#66d9ef">new</span> ManhattanDistanceMetric();
<span style="color:#66d9ef">var</span> speciationStrategy = <span style="color:#66d9ef">new</span> ParallelKMeansClusteringStrategy&lt;NeatGenome&gt;
    (distanceMetric);

<span style="color:#66d9ef">var</span> complexityRegulationStrategy = <span style="color:#66d9ef">new</span> NullComplexityRegulationStrategy();

<span style="color:#66d9ef">var</span> network = <span style="color:#66d9ef">new</span> NeatEvolutionAlgorithm&lt;NeatGenome&gt;
    (neatParameters, speciationStrategy, complexityRegulationStrategy);

<span style="color:#66d9ef">var</span> activationScheme = NetworkActivationScheme
    .CreateCyclicFixedTimestepsScheme(<span style="color:#ae81ff">1</span>);
<span style="color:#66d9ef">var</span> genomeDecoder = <span style="color:#66d9ef">new</span> NeatGenomeDecoder(activationScheme);

<span style="color:#66d9ef">var</span> phenomeEvaluator = <span style="color:#66d9ef">new</span> YourPhenomeEvaluator();
<span style="color:#66d9ef">var</span> genomeListEvaluator = 
    <span style="color:#66d9ef">new</span> ParallelGenomeListEvaluator&lt;NeatGenome, IBlackBox&gt;
        (genomeDecoder, phenomeEvaluator, parallelOptions);

network.Initialize(genomeListEvaluator, neatGenomeFactory, genomeList);

<span style="color:#75715e">//Optional
</span><span style="color:#75715e"></span>network.UpdateScheme = <span style="color:#66d9ef">new</span> UpdateScheme(logRate);
network.UpdateEvent += Ea_UpdateEvent;

network.StartContinue();
<span style="color:#66d9ef">while</span> (network.RunState != RunState.Paused)
{
    Thread.Sleep(<span style="color:#ae81ff">100</span>);
}
network.Stop();
</code></pre></div><p>I know, it looks complicated, but let explain it line by line.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> neatGenomeFactory = <span style="color:#66d9ef">new</span> NeatGenomeFactory(inputCount, outputCount);
</code></pre></div><p>At first, create factory for initial population with specified input and output neurons.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> genomeList = neatGenomeFactory.CreateGenomeList(specimenCount, <span style="color:#ae81ff">0</span>);
</code></pre></div><p>Then, create initial genome list with length of <code>specimenCount</code> and first generation number <code>0</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> neatParameters = <span style="color:#66d9ef">new</span> NeatEvolutionAlgorithmParameters
{
    SpecieCount = specimenCount
};
</code></pre></div><p>Here create parameters for your network. Absolute minimum that you have to provide is specimen count in each generation. It should be the same as length of <code>genomeList</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> distanceMetric = <span style="color:#66d9ef">new</span> ManhattanDistanceMetric();
<span style="color:#66d9ef">var</span> speciationStrategy = <span style="color:#66d9ef">new</span> ParallelKMeansClusteringStrategy&lt;NeatGenome&gt;
    (distanceMetric);
</code></pre></div><p>Here things start to be a bit kore tricky. To create <a href="http://en.wikipedia.org/wiki/K-means_clustering">k-means clustering method</a> You must provide <code>IDistanceMetric</code>. I used <code>ManhattanDistanceMetric</code>. About various types of distance metrics You can read <a href="https://medium.com/analytics-vidhya/various-types-of-distance-metrics-machine-learning-cc9d4698c2da">here</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> complexityRegulationStrategy = <span style="color:#66d9ef">new</span> NullComplexityRegulationStrategy();
</code></pre></div><p>Complexity regulation strategies reguletes if Your network tend to be more simple or more complex. <code>NullComplexityRegulationStrategy</code> is just strategy that is fixed to complexifying your network. In my cases it worked best.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> network = <span style="color:#66d9ef">new</span> NeatEvolutionAlgorithm&lt;NeatGenome&gt;
    (neatParameters, speciationStrategy, complexityRegulationStrategy);
</code></pre></div><p><code>NeatEvolutionAlgorithm&lt;NeatGenome&gt;</code> is just fancy word for your neural network. Just provide already created objects and let sharpneat do magic.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> activationScheme = NetworkActivationScheme
    .CreateCyclicFixedTimestepsScheme(<span style="color:#ae81ff">1</span>);
<span style="color:#66d9ef">var</span> genomeDecoder = <span style="color:#66d9ef">new</span> NeatGenomeDecoder(activationScheme);
</code></pre></div><p>To create <code>genomeDecoder</code> you have to create <code>activationScheme</code> first.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> phenomeEvaluator = <span style="color:#66d9ef">new</span> YourPhenomeEvaluator();
</code></pre></div><p>At this moment You have to write your first own code. You have to create class that can score fitness of your network.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">YourPhenomeEvaluator</span> : IPhenomeEvaluator&lt;IBlackBox&gt;
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">ulong</span> EvaluationCount =&gt; <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> StopConditionSatisfied =&gt; shouldEnd;
    <span style="color:#66d9ef">bool</span> shouldEnd = <span style="color:#66d9ef">false</span>;
    <span style="color:#66d9ef">public</span> FitnessInfo Evaluate(IBlackBox phenome)
    {
        <span style="color:#75715e">//phenome.InputSignalArray[index] - input neuron array
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//phenome.OutputSignalArray[index] - output neuron array
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> FitnessInfo(fitness, fitness);
    }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Reset() { }
}
</code></pre></div><p>What <code>IPhenomeEvaluator</code> should do is quite obvious but let explain it too.</p>
<p><code>EvaluationCount</code> is count of all evaluations of Your network(You don&rsquo;t have to implement this unless you want to use it).</p>
<p>When <code>StopConditionSatisfied</code> returns <code>true</code> training of Your network stops. Very usefull if e.g. network achieved maximum fitness.</p>
<p><code>Evaluate</code> Method takes network as an input and returns its fitness.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> genomeListEvaluator = 
    <span style="color:#66d9ef">new</span> ParallelGenomeListEvaluator&lt;NeatGenome, IBlackBox&gt;
        (genomeDecoder, phenomeEvaluator, parallelOptions);
</code></pre></div><p><code>genomeListEvaluator</code> is able to evaluate whole list of genoms, using your phenome evaluator.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">network.Initialize(genomeListEvaluator, neatGenomeFactory, genomeList);
</code></pre></div><p>Initialize alread created network with <code>genomeListEvaluator</code>, <code>neatGenomeFactory</code> and <code>genomeList</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#75715e">//Optional
</span><span style="color:#75715e"></span>network.UpdateScheme = <span style="color:#66d9ef">new</span> UpdateScheme(logRate);
network.UpdateEvent += Ea_UpdateEvent;
</code></pre></div><p>Each <code>logRate</code> generations <code>Ea_UpdateEvent</code> will be called.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">void</span> Ea_UpdateEvent(<span style="color:#66d9ef">object</span> sender, EventArgs e)
{
    <span style="color:#66d9ef">var</span> network = (NeatEvolutionAlgorithm&lt;NeatGenome&gt;)sender;
    Console.WriteLine(<span style="color:#e6db74">$&#34;Generation={network.CurrentGeneration} 
</span><span style="color:#e6db74">        bestFitness={network.Statistics._maxFitness:N6} 
</span><span style="color:#e6db74">        meanFitness={network.Statistics._meanFitness:N6}&#34;</span>);
}
</code></pre></div><p><code>Ea_UpdateEvent</code> can e.g. print network progress.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">network.StartContinue();
</code></pre></div><p>Start your network</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">while</span> (network.RunState != RunState.Paused)
{
    Thread.Sleep(<span style="color:#ae81ff">100</span>);
}
network.Stop();
</code></pre></div><p>Wait untill network is paused(e.g. when <code>YourPhenomeEvaluator.StopConditionSatisfied</code> returns <code>true</code>). Training runs in another thread so You have to block main thred, otherwise program will exit.</p>
<p>Those settings worked best for me, it won&rsquo;t be optimal for every project so don&rsquo;t worry to experiment with settings and parameters on your own.</p>
<p>I hope it will halp You creating Your own awesome machine learning project.</p>
<p>NOTE: I&rsquo;m not a professional data scientist.</p>
]]></content>
        </item>
        
        <item>
            <title>DashAI - Geometry Dash AI using NEAT</title>
            <link>/posts/dashai-geometry-dash-ai-using-neat/</link>
            <pubDate>Fri, 01 May 2020 11:39:44 +0200</pubDate>
            
            <guid>/posts/dashai-geometry-dash-ai-using-neat/</guid>
            <description>Geometry Dash is platformer game that I really like, but I suck at it, so I will try to create AI to play it for me. At first, I created simple geometry dash clone and following map.
You can stand on black tiles, red tiles kill. Simple. To create AI I used NEAT algorithm using sharpneat library. Neural network as input takes 7x7 tiles in front of player(picture below) and output is only one, jump or not.</description>
            <content type="html"><![CDATA[<p><a href="https://store.steampowered.com/app/322170/Geometry_Dash/">Geometry Dash</a> is platformer game that I really like, but I suck at it, so I will try to create AI to play it for me. At first, I created simple geometry dash clone and following map.</p>
<p><img src="/img/DashAI/MapD.png" alt="Map"></p>
<p>You can stand on black tiles, red tiles kill. Simple.
To create AI I used <a href="https://en.wikipedia.org/wiki/Neuroevolution_of_augmenting_topologies">NEAT</a> algorithm using <a href="https://github.com/colgreen/sharpneat">sharpneat</a> library. Neural network as input takes 7x7 tiles in front of player(picture below) and output is only one, jump or not.</p>
<p><img src="/img/DashAI/view.png" alt="Cat image"></p>
<p>So, network needs 49 input neuron for each tile type(black and red for now) and neural network on start looks like this(I know, nothing impressive)</p>
<p><img src="/img/DashAI/network1.png" alt="Network1"></p>
<p>It&rsquo;s time to train network. Training took couple of seconds on quad-core Xeon. After 115 generations with 150 specimens in each looks like that(still nothing amazing):</p>
<p><img src="/img/DashAI/network2.png" alt="Network2"></p>
<p>And AI can complete level:</p>
<p><img src="/img/DashAI/recording1.gif" alt="Recording1"></p>
<p>Training progress(fitness is percent of level completeness):</p>
<p><img src="/img/DashAI/progress1.png" alt="Progress1"></p>
<p>If network performs so great let introduce another tile. Green tile - It&rsquo;s possible to jump on it but it&rsquo;s not to stand on it. I created another simple map using new tile:</p>
<p><img src="/img/DashAI/MapE.png" alt="MapE"></p>
<p>Let see how AI can handle new tile type. This time training took a bit longer. AI required 511 generations. What&rsquo;s interesting, network is even simpler than previously.</p>
<p><img src="/img/DashAI/network3.png" alt="Network3"></p>
<p><img src="/img/DashAI/recording2.gif" alt="Recording1"></p>
<p>Training progress:</p>
<p><img src="/img/DashAI/progress2.png" alt="Progress1"></p>
<p>If you want to see how everything is implemented or even add something from yourself source code is available <a href="https://github.com/t4ccer/DashAI">here</a> (binaries are also available there)</p>
<h3 id="program-usage">Program usage:</h3>
<pre><code>DashAI OPTIONS
OPTIONS:
  -t Train network
  -p Play already trained network
</code></pre><h3 id="how-to-create-own-map">How to create own map:</h3>
<p>When creating own map squares colors must be exactly for</p>
<ul>
<li>Black(ground) - #000000</li>
<li>Red(kill) - #ff0000</li>
<li>Green(jump in air) - #00ff00</li>
</ul>
<p>Note that every other color will be interpreted as air(empty). For creating map I used <a href="https://www.getpaint.net/">paint.net</a> but any other graphics program should handle it.<br>
When running binary program map must be named &ldquo;Map.bmp&rdquo;, if compiling from source you can specify map name in NeatConsts.cs file</p>
]]></content>
        </item>
        
    </channel>
</rss>
